<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"  [ ]>

<chapter id="jpa-entityex-embedded">
    <title>Mapping Embedded Objects within Classes</title>
    <para>This chapter will take you through mapping nested classes to the database.
        In this case we have classes within classes (within classes, etc.) that get
        mapped to a flat database table. Note there are cases when the embedded class
        contains the meat of what we want mapped to our database and the wrapping
        entity may only be created to provide the necessary primary key property.
    </para>

    <section id="jpa-entityex-embedded-single">
        <title>Mapping an Embedded Object</title>
        <para>In this section we will map a simple embedded object within an entity class.</para>

        <orderedlist>
        
            <listitem><para>Add the following class to your src/main tree. In this case the entity
                class contains an instance of a Name class which contains two properties mapped to 
                the database. The Name class is annotated as @Embeddable and the name property in the 
                entity is annotated as @Embedded.</para>
<programlisting language="java"><![CDATA[
package myorg.entityex.annotated;

import javax.persistence.*;

@Entity
@Table(name="ENTITYEX_BEAR")
public class Bear {
    @Embeddable
    public static class Name {
        private String firstName;
        private String lastName;

        public String getFirstName() { return firstName; }
        public Name setFirstName(String firstName) { this.firstName = firstName; return this; }
        
        public String getLastName() { return lastName; }
        public Name setLastName(String lastName) { this.lastName = lastName; return this; }
    }

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;
    @Embedded
    private Name name;
    
    public int getId() { return id; }
    public void setId(int id) {
        this.id = id;
    }
    
    public Name getName() { return name; }
    public void setName(Name name) {
        this.name = name;
    }
}
]]></programlisting>                        
            </listitem>

            <listitem><para>Add the new entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.entityex.annotated.Bear</class>
]]></programlisting>                        
            </listitem>

            <listitem><para>Build the module and note the database schema created for the entity
                class. Note the embedded properties are now mapped at the same level as the 
                columns for the entity properties.</para>
<programlisting language=""><![CDATA[
    create table ENTITYEX_BEAR (
        id integer generated by default as identity,
        firstName varchar(255),
        lastName varchar(255),
        primary key (id)
    );
]]></programlisting>                        
            </listitem>

            <listitem><para>Add custom table mappings for the firstName and lastName properties.
                Define the mapping for firstName from within the embedded class. Define the 
                mapping for lastName from within the entity class.</para>
<programlisting language="java"><![CDATA[
    public static class Name {
        @Column(name="FIRST_NAME", length=16)
        private String firstName;
...
    @AttributeOverrides({
        @AttributeOverride(name="lastName", column=@Column(name="LAST_NAME", length=16))
    })
    @Embedded
    private Name name;
]]></programlisting>                        
            </listitem>
        
            <listitem><para>Rebuild the module and note the change in definition for the 
                firstName and lastName columns. We were able to control the mapping from 
                either within the embedded or entity class.</para>
<programlisting language=""><![CDATA[
    create table ENTITYEX_BEAR (
        id integer generated by default as identity,
        FIRST_NAME varchar(16),
        LAST_NAME varchar(16),
        primary key (id)
    );
]]></programlisting>                        
            </listitem>

        </orderedlist>
        <para>At this point we have shown how to map a single nested object.
            Note how similar this was to the @EmbeddedId case we went thru
            during the compound primary key chapter.</para>
    </section>

    <section id="jpa-entityex-embedded-multi">
        <title>Mapping Muti-level Embedded Objects</title>
        <para>The above is an example of a single-level embedded object
               that has been supported since JPA 1.0. In the next step, add a nested
               embedded object. Support for multiple levels of nesting was added in 
               JPA 2.0.</para>

        <orderedlist>
        
            <listitem><para>Add the following nested classes to the Bear entity class.</para>
<programlisting language="java"><![CDATA[
    @Embeddable
    public static class Street {
        private int number;
        private String name;
        
        public int getNumber() { return number; }
        public Street setNumber(int number) { this.number = number; return this; }
        
        public String getName() { return name; }
        public Street setName(String name) { this.name = name; return this; }
    }
    
    @Embeddable
    public static class Address {
        private Street street; //a second level of embedded
        //@Column(name="CITY", length=16)
        private String city;
        //@Column(name="STATE", length=16)
        private String state;

        public Street getStreet() { return street; }
        public Address setStreet(Street street) { this.street = street; return this; }
        
        public String getCity() { return city; }
        public Address setCity(String city) { this.city = city; return this; }
        
        public String getState() { return state; }
        public Address setState(String state) { this.state = state; return this; }
    }

    @Embedded
    private Address address;
    
    public Address getAddress() { return address; }
    public void setAddress(Address address) {
        this.address = address;
    }
]]></programlisting>                        
            </listitem>
        
            <listitem><para>Rebuild the module with the new, multi-level embedded class and
                note the database schema created. Both levels of the Address were flattened 
                into the entity table.</para>
<programlisting language=""><![CDATA[
    create table ENTITYEX_BEAR (
        id integer generated by default as identity,
        city varchar(255),
        state varchar(255),
        name varchar(255),
        number integer not null,
        FIRST_NAME varchar(16),
        LAST_NAME varchar(16),
        primary key (id)
    );
]]></programlisting>                        
            </listitem>
        
            <listitem><para>Define custom table mappings for the address.</para>
                <itemizedlist spacing="compact">
                    <listitem><para>Leave Street un-customized</para>
<programlisting language=""><![CDATA[
    public static class Street {
        private int number;
        private String name;
]]></programlisting>                        
                    </listitem>
                    <listitem><para>Map Street.number to the STREET_NUMBER column
                       from the Address class.</para>
<programlisting language=""><![CDATA[
    @Embeddable
    public static class Address {
        @AttributeOverrides({
            @AttributeOverride(name="number", column=@Column(name="STREET_NUMBER")),
        })
        private Street street; //a second level of embedded
]]></programlisting>                        
                    </listitem>
                    <listitem><para>Map Street.name to a 16 character STREET_NAME column
                        from the entity class. Note the multiple level syntax here.</para>
<programlisting language=""><![CDATA[
    @AttributeOverrides({
        @AttributeOverride(name="street.name", column=@Column(name="STREET_NAME", length=16)),
    })
    @Embedded
    private Address address;
]]></programlisting>                        
                    </listitem>
                </itemizedlist>
            </listitem>
        
            <listitem><para>Rebuild the module and note the generated database schema. Our 
                custom database mappings are in place.</para>
<programlisting language=""><![CDATA[
    create table ENTITYEX_BEAR (
        id integer generated by default as identity,
        CITY varchar(16),
        STATE varchar(16),
        STREET_NAME varchar(16),
        STREET_NUMBER integer,
        FIRST_NAME varchar(16),
        LAST_NAME varchar(16),
        primary key (id)
    );
]]></programlisting>                        
            </listitem>
        
            <listitem><para>Put the following test method within the existing JUnit test case.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testEmbeddedObject() {
        log.info("testEmbeddedObject");
        Bear bear = new Bear();
        bear.setName(new Bear.Name().setFirstName("Yogi").setLastName("Bear"));
        bear.setAddress(new Bear.Address()
            .setCity("Jellystone Park")
            .setState("???")
            .setStreet(new Bear.Street().setNumber(1).setName("Picnic")));
        em.persist(bear);
        
        //flush to DB and get a new instance
        em.flush(); em.detach(bear);
        Bear bear2 = em.find(Bear.class, bear.getId());
        assertEquals("unexpected firstName", bear.getName().getFirstName(), bear2.getName().getFirstName());
        assertEquals("unexpected lastName", bear.getName().getLastName(), bear2.getName().getLastName());
        assertEquals("unexpected street number", 
                bear.getAddress().getStreet().getNumber(), bear2.getAddress().getStreet().getNumber());
        assertEquals("unexpected street name", 
                bear.getAddress().getStreet().getName(), bear2.getAddress().getStreet().getName());
        assertEquals("unexpected city", 
                bear.getAddress().getCity(), bear2.getAddress().getCity());
        assertEquals("unexpected state", 
                bear.getAddress().getState(), bear2.getAddress().getState());
    }
]]></programlisting>                        
            </listitem>
        
            <listitem><para>Rebuild the module with the new test method in place.</para>
<programlisting language=""><![CDATA[
 -testEmbeddedObject
Hibernate: 
    insert 
    into
        ENTITYEX_BEAR
        (id, CITY, STATE, STREET_NAME, STREET_NUMBER, FIRST_NAME, LAST_NAME) 
    values
        (null, ?, ?, ?, ?, ?, ?)
Hibernate: 
    select
        bear0_.id as id7_0_,
        bear0_.CITY as CITY7_0_,
        bear0_.STATE as STATE7_0_,
        bear0_.STREET_NAME as STREET4_7_0_,
        bear0_.STREET_NUMBER as STREET5_7_0_,
        bear0_.FIRST_NAME as FIRST6_7_0_,
        bear0_.LAST_NAME as LAST7_7_0_ 
    from
        ENTITYEX_BEAR bear0_ 
    where
        bear0_.id=?
]]></programlisting>                        
            </listitem>

        </orderedlist>
        
        <para>The above capability of mapping multi-nested classes was added in JPA 2.0
            and allows us to map more complicated structures to the database.</para>
    </section>


    <section id="jpa-entityex-embedded-summary">
       <title>Summary</title>
       <para>In this chapter we mapped a nested object within the table used to host
           and enclosing entity class. Note there are times when the entity is created
           purely for persistence purposes and the embedded class is the real meat we
           are after. In that case, the entity class is imply providing the primary key
           property and embedding the rest.</para>
    </section>    
</chapter>
  
